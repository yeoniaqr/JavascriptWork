<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>[Object(객체)] 08.객체 합치는 4가지 방법 (merge)</title>

</head>

<body>
  <header>
    <h2>[Object(객체)] 08.객체 합치는 4가지 방법 (merge)</h2>
    <p>
      반복문 사용하기<br />
      Object.assign()<br />
      Spread Operator (전개연산자)<br />
      _.merge() (lodash 라이브러리)<br />
    </p>
  </header>

  <script>
    /*---------------------------------------------------------------------
      1. 반복문 사용하기
    ---------------------------------------------------------------------*/
    const obj1 = {
      name: 'banana',
      price: 1000
    };

    const obj2 = {
      name: 'banana',
      price: 2000,
      count: 10
    };

    // merge object 함수
    function mergeObj(obj1, obj2) {
      const newObj = {};
      for (let att in obj1) {
        newObj[att] = obj1[att];
      }

      for (let att in obj2) {
        newObj[att] = obj2[att];
      }

      return newObj;
    }

    // 결과 출력
    document.write(JSON.stringify(mergeObj(obj1, obj2)));

    /*---------------------------------------------------------------------
      2. Object.assign()
          Object.assign(target, ...sources)

          파라미터로 입력받은 sources 객체들의 속성을 target 객체로 복사합니다.
          이때, sources 객체는 1개이상 여러개 입력 가능합니다.
    ---------------------------------------------------------------------*/
    const obj3 = {
      name: 'banana',
      price: 1000
    };

    const obj4 = {
      name: 'banana',
      count: 10
    };

    Object.assign(obj3, obj4);

    //obj4의 모든 속성들을 obj3에 복사합니다.
    //이때 같은 속성이 있으면 덮어씁니다.
    //출력 결과를 보면 obj3에 obj4의 속성들이 복사된 것을 볼 수 있습니다.

    // 결과 출력
    document.write("obj3 : " + JSON.stringify(obj3) + '<br>');
    document.write("obj4 : " + JSON.stringify(obj4));


    //  예제 2  -----------------------------------------------------------
    const obj5 = {
      name: 'banana',
      price: 1000
    };

    const obj6 = {
      name: 'banana',
      count: 10
    };

    const obj7 = {
      count: 100,
      color: 'yellow'
    }

    Object.assign(obj5, obj6, obj7);

    // obj6와 obj7 객체의 속성들을 obj5에 복사합니다.
    // obj6의 count는 10이고, obj7의 count는 100입니다.
    // 이렇게 source object의 속성이 겹치는 경우,
    // Object.assign 함수의 파라미터로 전달된 순서가 뒤인 객체의 값이 복사됩니다.


    // 결과 출력
    document.write("obj5 : " + JSON.stringify(obj5) + '<br>');
    document.write("obj6 : " + JSON.stringify(obj6) + '<br>');
    document.write("obj7 : " + JSON.stringify(obj7));



    //  예제 3  -----------------------------------------------------------
    const obj8 = {
      name: 'banana',
      price: 1000
    };

    const obj9 = {
      name: 'banana',
      count: 10
    };

    const newObj2 = Object.assign({}, obj8, obj9);

    // Object.assign() 함수로 객체를 복사하면
    // Object.assign() 함수의 첫번째 파라미터로 전달된 target 객체가 변경됩니다.
    //   그래서, 예제1과 예제2에서는 target 객체로 전달된 obj1 객체가 변경되었습니다.

    // const newObj2 = Object.assign({}, obj8, obj9);
    // obj8과 obj9 객체를 변경하지 않고,
    // 두 객체를 병합하여 새로운 객체를 만들기 위해서
    // 위 예제(예제3)와 같이 target 객체 위치에 빈 객체({})를 전달하였습니다.
    // 그러면, obj8객체와 obj9 객체가 빈 객체({})에 복사되어 병합됩니다.
    // 그리고, 병합된 객체는 Object.assign() 함수의 리턴값으로 리턴됩니다.

    // 위 예제의 출력 결과를 보면
    // obj8과 obj9는 변경이 되지 않았고,
    // 병합된 결과는 Object.assign()의 리턴값인 newObj2에서 확인할 수 있습니다.

    // 결과 출력
    document.write("newObj2 : " + JSON.stringify(newObj2) + '<br>');
    document.write("obj8 : " + JSON.stringify(obj8) + '<br>');
    document.write("obj9 : " + JSON.stringify(obj9) + '<br>');




    /*---------------------------------------------------------------------
      3. Spread Operator (전개연산자)
    ---------------------------------------------------------------------*/
    const obj10 = {
      name: 'banana',
      price: 1000
    };

    const obj11 = {
      name: 'banana',
      count: 10
    };

    const newObj3 = { ...obj10, ...obj11 }

    //Spread Operator를 사용해서 여러개의 객체를 하나로 병합할 수 있습니다.
    // Spread Operator는 '...'으로 표시하고, 객체나 배열의 원소를 하나씩 펼쳐서 리턴합니다.
    // 즉, 위 코드는 obj10와 obj11의 각각의 속성들을 하나씩 꺼내어 새로운 객체에 넣어줍니다.


    // 결과 출력
    document.write("newObj3 : " + JSON.stringify(newObj3) + '<br>');
    document.write("obj10 : " + JSON.stringify(obj10) + '<br>');
    document.write("obj11 : " + JSON.stringify(obj11) + '<br>');


    /*---------------------------------------------------------------------
      4. _.merge (lodash 라이브러리)
    ---------------------------------------------------------------------*/
    const obj12 = {
      name: 'Kim',
      tel: ['010-1111-1111', '010-2222-2222'],
    };

    const obj13 = {
      name: 'Kim',
      address: 'Seoul'
    };

    const newObj4 = { ...obj12, ...obj13 }

    // 변경 전 결과 출력
    document.write("변경 전" + '<br>');
    document.write("newObj4 : " + JSON.stringify(newObj4) + '<br>');

    // obj12.tel 배열에 값 추가
    obj12.tel.push('010-3333-3333');

    // 변경 후 결과 출력
    document.write("변경 후" + '<br>');
    document.write("newObj4 : " + JSON.stringify(newObj4) + '<br>');

    /*
      Spread Operator나 Object.assign을 이용해서 객체를 병합하면
      Shallow Copy(얕은 복사)가 되면서 두 객체가 합쳐집니다.
      Spread Operator나 Object.assign()을 이용하면 위 의 예제와 같이
      객체의 속성값이 Object(객체)이거나 Array와 같이 Reference Type일 경우에는
      해당 객체의 값이 복사되는게 아니라, 해당 객체를 참조하는 주소값을 복사하면서
      두 객체를 병합하게 됩니다.

      (Reference Type이 아닌, 문자열이나 숫자 등은 주소값이 아닌 실제값이 복사됩니다.)

      실제 값이 복사된 것이 아닌 주소값이 복사되었기 때문에
      위 예제에서 obj1.tel의 배열에 새로운 값을 추가했는데도
      두 객체의 병합으로 만들어진 newObj의 tel값도 같이 변경된 것을 확인할 수 있습니다.
      여기서는 Spread Operator로 예제를 만들었지만, 이것은 Object.assign()의 경우도 마찬가지 입니다.

      이러한 현상을 피하고,
      실제 값을 복사하고 싶을 때는 lodash 라이브러리의 '_.merge()' 함수를 이용할 수 있습니다. (Deep Copy)
    */



    const obj14 = {
      name: 'Kim',
      tel: ['010-1111-1111', '010-2222-2222'],
    };

    const obj15 = {
      name: 'Kim',
      address: 'Seoul'
    };

    const newObj5 = _.merge({}, obj14, obj15)

    // 변경 전 결과 출력
    document.write("변경 전" + '<br>');
    document.write("newObj5 : " + JSON.stringify(newObj5) + '<br>');

    // obj14.tel 배열에 값 추가
    obj14.tel.push('010-3333-3333');

    // 변경 후 결과 출력
    document.write("변경 후" + '<br>');
    document.write("newObj5 : " + JSON.stringify(newObj5) + '<br>');

    /*
      const newObj = _.merge({}, obj1, obj2);
      lodash의 '_.merge()' 함수는 Object.assign() 함수와 사용법이 비슷합니다.
      첫번째 파라미터로는 객체들이 병합될 target 객체를 입력하고,
      두번째 파라미터부터는 병합될 source 객체들을 나열합니다.
      _.merge() 함수를 이용하여 객체를 병합하니(newObj),
      obj1.tel의 배열에 새로운 값을 추가해도,
      newObj.tel의 배열값이 변경되지 않는 것을 확인 할 수 있습니다.
    */
  </script>
</body>

</html>